#include "elementy.h"
int crossingVertexCount=8;//16;

float crossingVertices[]={
        
	-1,-1,-1,
	-1,-1, 1,
	 1,-1, 1,
	 1,-1,-1,

	-1, 1,-1,
	-1, 1, 1,
	 1, 1, 1,
	 1, 1,-1

	
     
 
};

float crossingColors[]={
  
	1,1,1, 1,1,1, 1,1,1, 1,1,1,
	1,1,1, 1,1,1, 1,1,1, 1,1,1
	
};

// tablica ze wspolrzednymi tesktury - troche juz wiem jak to dziala
float crossingTexCoords[]={
	0,0, 1,0, 1,1, 0,1,
	0,0, 1,0, 1,1, 0,1
	
};

// tablica z wpolrzednymi do wektorow normalnych
float crossingNormals[]={
	-1,-1,-1,
	-1,-1, 1,
	 1,-1, 1,
	 1,-1,-1,

	-1, 1,-1,
	-1, 1, 1,
	 1, 1, 1,
	 1, 1,-1,

	
};

int corridorVertexCount=16;

float corridorVertices[]={
      
	-1,-1,-1,
	-1,-1, 1,
	 1,-1, 1,
	 1,-1,-1,

	-1, 1,-1,
	-1, 1, 1,
	 1, 1, 1,
	 1, 1,-1,

	-1,-1,-1,
	-1,-1, 1,
	-1, 1, 1,
	-1, 1,-1,

	 1,-1,-1,
	 1,-1, 1,
	 1, 1, 1,
	 1, 1,-1
      
 
};

float corridorColors[]={
  
	1,1,1, 1,1,1, 1,1,1, 1,1,1,
	1,1,1, 1,1,1, 1,1,1, 1,1,1,
	1,1,1, 1,1,1, 1,1,1, 1,1,1,
	1,1,1, 1,1,1, 1,1,1, 1,1,1
};

// tablica ze wspolrzednymi tesktury - troche juz wiem jak to dziala
float corridorTexCoords[]={
	
	0,0, 1,0, 1,1, 0,1,
	0,0, 1,0, 1,1, 0,1,
	0,0, 1,0, 1,1, 0,1,
	0,0, 1,0, 1,1, 0,1
	
};

// tablica z wpolrzednymi do wektorow normalnych
float corridorNormals[]={
  
	-1,-1,-1,
	-1,-1, 1,
	 1,-1, 1,
	 1,-1,-1,

	-1, 1,-1,
	-1, 1, 1,
	 1, 1, 1,
	 1, 1,-1,

	-1,-1,-1,
	-1,-1, 1,
	-1, 1, 1,
	-1, 1,-1,

	 1,-1,-1,
	 1,-1, 1,
	 1, 1, 1,
	 1, 1,-1
};

int endingVertexCount=4;//16;

float endingVertices[]={
      
      
	-1,-1,-1,
	-1, 1,-1,
	 1, 1,-1,
	 1,-1,-1
      
};

float endingColors[]={
  
	1,1,1, 1,1,1, 1,1,1, 1,1,1
	
};

// tablica ze wspolrzednymi tesktury - troche juz wiem jak to dziala
float endingTexCoords[]={
	0,0, 1,0, 1,1, 0,1
	
};

// tablica z wpolrzednymi do wektorow normalnych
float endingNormals[]={
  
	-1,-1,-1,
	-1, 1,-1,
	 1, 1,-1,
	 1,-1,-1

	
};

GLuint tex4; //Globalnie
TGAImg img4; //Obojętnie czy globalnie, czy lokalnie

void draw_crossing(glm::mat4 V, float x, float y, float z)
{
  
}

void draw_corridor(glm::mat4 V, float x, float y, float z)
{
//*
    glm::mat4 M=glm::mat4(1.0f);
    M=glm::translate(M,glm::vec3(x,y,z));

    glLoadMatrixf(glm::value_ptr(V*M));
    
    
 	  //crossing
    if (img4.Load("bricks.tga")==IMG_OK) 
    {

      glGenTextures(1,&tex4); //Zainicjuj uchwyt tex
      glBindTexture(GL_TEXTURE_2D,tex4); //Przetwarzaj uchwyt tex
      if (img4.GetBPP()==24) //Obrazek 24bit
	  glTexImage2D(GL_TEXTURE_2D,0,3,img4.GetWidth(),img4.GetHeight(),0,
	  GL_RGB,GL_UNSIGNED_BYTE,img4.GetImg());
      else if (img4.GetBPP()==32)
	  //Obrazek 32bit
	  glTexImage2D(GL_TEXTURE_2D,0,4,img4.GetWidth(),img4.GetHeight(),0,
	  GL_RGBA,GL_UNSIGNED_BYTE,img4.GetImg());
      else 
      {
	  //Obrazek 16 albo 8 bit, takimi się nie przejmujemy
      }
    } 
    else 
    {
	  
    }
	
	
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S, GL_REPEAT);	
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T, GL_REPEAT);
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D,tex4);// do tekstury
  
  
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    glEnableClientState( GL_NORMAL_ARRAY );
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
      
    
    glNormalPointer( GL_FLOAT, 0, corridorNormals);
    glVertexPointer(3,GL_FLOAT,0,corridorVertices);
    glColorPointer(3,GL_FLOAT,0,corridorColors);// do kolorow
    
    glDrawArrays(GL_QUADS,0,corridorVertexCount);
   
    glDisableClientState( GL_NORMAL_ARRAY );
    glDisableClientState( GL_VERTEX_ARRAY );
    glDisableClientState( GL_COLOR_ARRAY );
    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
    
 
    
    
    
    
    
}
void draw_ending(glm::mat4 V, float x, float y, float z)
{
  
}